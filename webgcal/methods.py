import atom
import urllib
import urllib2
import logging
import datetime
import hcalendar
import gdata.service
import gdata.calendar
import gdata.calendar.service
from google.appengine.ext import deferred
from django.contrib.auth.decorators import login_required, permission_required
from django.http import HttpResponse
from webgcal.models import Calendar, Website, Event
from webgcal.tokens import run_on_django

def start_worker(request):
    for calendar in Calendar.objects.all():
        for website in calendar.websites:
            website.running = True
            website.save()
            deferred.defer(_parse_website, calendar.id, website.id)
    return HttpResponse('deferred')

def update_calendar(request, calendar_id):
    deferred.defer(_update_calendar, calendar_id)
    return HttpResponse('deferred')

def parse_website(request, calendar_id, website_id):
    deferred.defer(_parse_website, calendar_id, website_id)
    return HttpResponse('deferred')


def _update_calendar(calendar_id, offset=0, limit=10):    
    try:
        calendar = Calendar.objects.get(id=calendar_id)
    
        if not calendar.enabled:
            return
    
        calendar.running = True
        calendar.save()
    
        calendar_service = run_on_django(gdata.calendar.service.CalendarService())
        calendar_service.token_store.user = calendar.user
        calendar_service.AuthSubTokenInfo()
        
        calendar_remote = None
        calendar_link = None
        
        if calendar.href:
            calendars = calendar_service.GetOwnCalendarsFeed()
            logging.info('Queried calendars feed for %s' % calendar.user)
            
            for cal in calendars.entry:
                if cal.id.text == calendar.href:
                    calendar_remote = cal
        
        if not calendar_remote:
            cal = gdata.calendar.CalendarListEntry()
            cal.title = atom.Title(text=calendar.name)
            cal.summary = atom.Summary(text='%s generated by webgcal.appspot.com' % calendar.name)
            cal.hidden = gdata.calendar.Hidden(value='false')
            
            calendar_remote = calendar_service.InsertCalendar(new_calendar=cal)
            logging.info('Inserted calendar %s for %s' % (calendar.name, calendar.user))
            
            calendar.href = calendar_remote.id.text
            calendar.save()
        
        if calendar_remote:
            for link in calendar_remote.link:
                if link.rel == 'http://schemas.google.com/gCal/2005#eventFeed':
                    calendar_link = link
                    
        if calendar_remote and calendar_link:
            logging.info('Starting calendar %s sync for %s' % (calendar.name, calendar.user))
            batch = gdata.calendar.CalendarEventFeed()
            
            events = []
            websites = calendar.websites.count()
            for website in calendar.websites:
                for event in website.events:
                    events.append((event, website))
            
            logging.info('Events with offset at %d and limit of %d' % (offset, limit))
            
            requests = {}
            for event, website in events[offset:offset+limit]:
                if event.href:
                    try:
                        entry = calendar_service.GetCalendarEventEntry(event.href)
                    except:
                        event.href = ''
            
                if event.href:
                    if not event.deleted:
                        if websites > 1:
                            entry.title = atom.Title(text=u'%s: %s' % (website.name, event.summary))
                        else:
                            entry.title = atom.Title(text=event.summary)
                        if event.dtstart.hour == 0 and event.dtstart.minute == 0 and event.dtstart.second == 0:
                            entry.when = [gdata.calendar.When(start_time=event.dtstart.strftime('%Y-%m-%d'), end_time=(event.dtstart+datetime.timedelta(days=1)).strftime('%Y-%m-%d'))]
                        else:
                            entry.when = [gdata.calendar.When(start_time=event.dtstart.strftime('%Y-%m-%dT%H:%M:%S%z'))]
                        entry.transparency = gdata.calendar.Transparency()
                        entry.transparency.value = 'TRANSPARENT'
                        entry.batch_id = gdata.BatchId(text='update-request-%d' % event.id)
                        batch.AddUpdate(entry=entry)
                        requests[entry.batch_id.text] = event
                        logging.info('Updating event %s' % event.summary)
                        
                    else:
                        entry.batch_id = gdata.BatchId(text='delete-request-%d' % event.id)
                        batch.AddDelete(entry=entry)
                        requests[entry.batch_id.text] = event
                        logging.info('Deleting event %s' % event.summary)
                
                else:
                    if not event.deleted:
                        entry = gdata.calendar.CalendarEventEntry()
                        if websites > 1:
                            entry.title = atom.Title(text=u'%s: %s' % (website.name, event.summary))
                        else:
                            entry.title = atom.Title(text=event.summary)
                        if event.dtstart.hour == 0 and event.dtstart.minute == 0 and event.dtstart.second == 0:
                            entry.when = [gdata.calendar.When(start_time=event.dtstart.strftime('%Y-%m-%d'), end_time=(event.dtstart+datetime.timedelta(days=1)).strftime('%Y-%m-%d'))]
                        else:
                            entry.when = [gdata.calendar.When(start_time=event.dtstart.strftime('%Y-%m-%dT%H:%M:%S%z'))]
                        entry.transparency = gdata.calendar.Transparency()
                        entry.transparency.value = 'TRANSPARENT'
                        entry.batch_id = gdata.BatchId(text='insert-request-%d' % event.id)
                        batch.AddInsert(entry=entry)
                        requests[entry.batch_id.text] = event
                        logging.info('Inserting event %s' % event.summary)
                        
                    else:
                        event.delete()
                        logging.info('Deleted event %s' % event.summary)
          
            calendar_events = calendar_service.GetCalendarEventFeed(calendar_link.href)
            result = calendar_service.ExecuteBatch(batch, calendar_events.GetBatchLink().href)
            logging.info('Executed batch request')
            
            for entry in result.entry:
                if entry.batch_id and entry.batch_id.text in requests and entry.batch_status.code in ['200', '201']:
                    logging.info('%s %s %s' % (entry.batch_id.text, entry.batch_status.code, entry.batch_status.reason))
                    event = requests[entry.batch_id.text]
                    if event.deleted and entry.batch_operation.type == 'delete':
                        event.delete()
                    else:
                        event.href = entry.id.text
                        event.save()
                else:
                    logging.warning(entry)
            
            if offset+limit < len(events):
                deferred.defer(_update_calendar, calendar_id, offset+limit, limit)
                logging.info('Deferred calendar %s sync for %s' % (calendar.name, calendar.user))
            else:
                calendar.running = False
                calendar.update = datetime.datetime.now()
                calendar.save()
                logging.info('Finished calendar %s sync for %s' % (calendar.name, calendar.user))

    except gdata.service.RequestError, e:
        if e.args[0]['status'] == 401 and calendar.errors < 15:
            calendar.errors += 1
            calendar.save()
            raise deferred.Error(e)
        elif e.args[0]['status'] == 401 or e.args[0]['status'] == 403:
            calendar.enabled = False
            calendar.running = False
            calendar.errors = 0
            calendar.save()
            raise deferred.PermanentTaskFailure(e)
        else:
            calendar.running = False
            calendar.errors = 0
            calendar.save()
            raise deferred.PermanentTaskFailure(e)
            
    except gdata.service.NonAuthSubToken, e:
        calendar.enabled = False
        calendar.running = False
        calendar.errors = 0
        calendar.save()
        raise deferred.PermanentTaskFailure(e)

    except Calendar.DoesNotExist, e:
        raise deferred.PermanentTaskFailure(e)


def _parse_website(calendar_id, website_id):
    try:
        calendar = Calendar.objects.get(id=calendar_id)
        website = Website.objects.get(calendar=calendar, id=website_id)
        
        if not website.enabled:
            return
            
        website.running = True
        website.save()
        
        logging.info('Parsing website %s for %s' % (website.name, calendar.user))
        
        events_remote = {}
        html = urllib2.urlopen(urllib2.Request(website.href, headers={'User-agent': 'WebGCal'})).read()
        for cal in hcalendar.hCalendar(html):
            for event in cal:
                if event.summary and event.dtstart:
                    events_remote[hash(event.summary)^hash(event.dtstart)] = event
        
        logging.info('Parsed website %s for %s' % (website.name, calendar.user))
        
        events = {}
        for event in website.events:
            events[hash(event.summary)^hash(event.dtstart)] = event
        
        logging.info('Updating website %s for %s' % (website.name, calendar.user))
        
        for key, event_remote in events_remote.iteritems():
            if not key in events:
                Event.objects.create(website=website, summary=event_remote.summary, dtstart=event_remote.dtstart)
            else:
                event = events[key]
                event.summary = event_remote.summary
                event.dtstart = event_remote.dtstart
                event.save()
        
        for key, event in events.iteritems():
            if not key in events_remote:
                event.deleted = True
                event.save()
                
        website.running = False
        website.update = datetime.datetime.now()
        website.save()
        logging.info('Updated website %s for %s' % (website.name, calendar.user))
        
        if not calendar.websites.filter(running=True).count():
            deferred.defer(_update_calendar, calendar_id)
            logging.info('Deferred calendar %s sync for %s' % (calendar.name, calendar.user))
        
    except Calendar.DoesNotExist, e:
        raise deferred.PermanentTaskFailure(e)
        
    except Website.DoesNotExist, e:
        raise deferred.PermanentTaskFailure(e)
